// import {db} from '../database/db'
import { exec } from 'child_process';
import { promisify } from 'util';

import { Database, open } from 'sqlite';
import sqlite3 from 'sqlite3';
sqlite3.verbose();

type DbType = Database<sqlite3.Database, sqlite3.Statement>;

async function initDb(dbName: string): Promise<DbType> {
  return open({
    filename: dbName,
    driver: sqlite3.Database,
    mode: sqlite3.OPEN_READONLY,
  });
}

// import os from 'os'
const promisifiedExec = promisify(exec);
import { Convert as VulnCast, Vulnerabilities } from '../types/grypeVulnerabilities';
import { Convert as MetaCast, VulnerabilityMetadata } from '../types/grypeVulnerabilityMetadata';

interface LoadedData {
  vulns: Vulnerabilities[];
  meta: VulnerabilityMetadata[];
}
export class Vulnerability {
  // todo: Put in an SNS warning on failure
  static async loadVulnerabilities(dbPath: string) {
    const loadedData = await this.readVulnsFromDb(dbPath);
    // console.log(loadedData.meta);
    this.joinVulnsAndMeta(loadedData);
  }

  private static async readVulnsFromDb(dbPath: string): Promise<LoadedData> {
    await promisifiedExec('grype db update');
    const db = await initDb(dbPath);

    const rawVulns = await db.all('SELECT * FROM vulnerability');
    const vulns = VulnCast.jsonBlobToVulnerabilities(rawVulns as Record<string, any>);

    const rawMeta = await db.all('SELECT * FROM vulnerability_metadata');
    const meta = MetaCast.jsonBlobToVulnerabilityMetadata(rawMeta as Record<string, any>);

    return { vulns, meta };
  }

  private static joinVulnsAndMeta(loadedData: LoadedData) {
    const metaIndex = this.buildMetaIndex(loadedData.meta);
    console.log('built index ', metaIndex);
  }

  private static buildMetaIndex(meta: VulnerabilityMetadata[]) {
    const metaIndex: Record<string, VulnerabilityMetadata> = {};
    meta.forEach((metaItem) => {
      const indexKey = metaItem.id + ':' + metaItem.namespace;
      metaIndex[indexKey] = metaItem;
    });
    return metaIndex;
  }
  // return new Promise((resolve, reject) => {
  // const db = new sqlite3.Database(path.join(sqliteDbFolder, 'vulnerability.db'), sqlite3.OPEN_READONLY);
  // const res;
  // await promisifiedExec('cp -f ~/.cache/grype/db/3/vulnerability.db')
  // const { stdout, stderr } = await promisifiedExec(
  //   `sqlite3 ${path.join(sqliteDbFolder, '/vulnerability.db')} '.mode json' '.once ${path.resolve(
  //     sqliteDbFolder,
  //     'vulndump.json'
  //   )}' 'SELECT * FROM vulnerability INNER JOIN vulnerability_metadata on vulnerability.id = vulnerability_metadata.id LIMIT 5'`
  // );
  // console.log('dump stdout: ', stdout);
  // console.log('dump stderr: ', stderr);
  // const rawVulns = require(path.join(sqliteDbFolder, 'vulndump.json')); // it was too big to pipe from stdout but this works
  // console.log(rawVulns);
  // const sanitizedVulns = Convert.jsonBlobToVulnerabilities(rawVulns);
  // console.log(sanitizedVulns);
  // return Convert.toVulnerabilities(stdout);
}
