/*
 * Copyright 2022 by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import os from 'os';
import path from 'path';

import { db, pgp } from '../database/db';
import { PkgInfo, PkgVersion, VulnInfo } from '../types/vulnInfo';
import { VulnerabilityLoader } from '../utils/vulnerabilityLoader';

export class Vulnerability {
  static async updateVulnDb() {
    console.log('beginning vuln update');
    const grypeDbPath = path.join(os.homedir(), '.cache/grype/db/3/vulnerability.db');

    const { vulns, pkgs, pkgVersions } = await VulnerabilityLoader.loadVulnerabilities(grypeDbPath);

    console.log('loaded ', vulns.length, ' vulns from grype sqlite');
    console.log('and ', pkgs.length, ' pkgs');
    console.log('and ', pkgVersions.length, ' pkgVersions');
    // todo: move to dedicated sql files
    // do NOT use template strings
    const vulnUpsertQuery = this.buildVulnQuery(vulns);
    await db.tx((t) => {
      const vulnUpsert = t.none(vulnUpsertQuery);

      const pkgInsertQuery = this.buildPkgsInsertQuery(pkgs);
      const insertPkgs = t.none(pkgInsertQuery);

      const pkgVersionInsertQuery = this.buildPkgVersionInsertQuery(pkgVersions);
      const insertPkgVersions = t.none(pkgVersionInsertQuery);
      return t.batch([vulnUpsert, insertPkgs, insertPkgVersions]);
    });
    console.log('donezo');
  }

  private static buildVulnQuery(vulns: VulnInfo[]): string {
    const columns = new pgp.helpers.ColumnSet(
      [
        'name',
        'namespace',
        'slug',
        'data_source',
        'record_source',
        'severity',
        'urls',
        'description',
        'related_vulnerabilities:json',
      ],
      { table: 'vulnerabilities' }
    );
    const insertQuery = pgp.helpers.insert(vulns, columns);
    return insertQuery.concat(` ON CONFLICT (slug) DO UPDATE
                        SET
                            data_source = EXCLUDED.data_source,
                            record_source = EXCLUDED.record_source,
                            severity = EXCLUDED.severity,
                            urls = EXCLUDED.urls,
                            description = EXCLUDED.description
                        `);
  }

  private static buildPkgsInsertQuery(pkgs: PkgInfo[]): string {
    const columns = new pgp.helpers.ColumnSet(['slug', 'vuln_slug', 'name', 'advisories'], {
      table: 'vulnerability_packages',
    });
    const query = pgp.helpers.insert(pkgs, columns);
    return query.concat(`ON CONFLICT (slug) DO UPDATE 
      SET 
        advisories = EXCLUDED.advisories
    `);
  }

  private static buildPkgVersionInsertQuery(pkgVersions: PkgVersion[]): string {
    const columns = new pgp.helpers.ColumnSet(
      ['slug', 'version_constraint', 'version_format', 'fixed_in_versions', 'fix_state', 'cpes:json', 'pkg_slug'],
      {
        table: 'package_versions',
      }
    );
    const query = pgp.helpers.insert(pkgVersions, columns);
    return query.concat(
      `ON CONFLICT (slug) DO UPDATE 
      SET 
        version_format = EXCLUDED.version_format, 
        fixed_in_versions = EXCLUDED.fixed_in_versions,
        fix_state = EXCLUDED.fix_state,
        cpes = EXCLUDED.cpes
      `
    );
  }
}
