/*
 * Copyright 2022 by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
// import {db} from '../database/db'
import { exec } from 'child_process';
import { promisify } from 'util';

import { Database, open } from 'sqlite';
import sqlite3 from 'sqlite3';

import { GrypeVuln, Convert as VulnCast } from '../types/grypeVulnerabilities';
import { GrypeMeta, Convert as MetaCast } from '../types/grypeVulnerabilityMetadata';
import { PkgInfo, VulnInfo } from '../types/vulnInfo';

sqlite3.verbose();
type DbType = Database<sqlite3.Database, sqlite3.Statement>;

async function initDb(dbName: string): Promise<DbType> {
  return open({
    filename: dbName,
    driver: sqlite3.Database,
    mode: sqlite3.OPEN_READONLY,
  });
}

// import os from 'os'
const promisifiedExec = promisify(exec);

interface GrypeData {
  vulns: GrypeVuln[];
  meta: GrypeMeta[];
}

export interface VulnReport {
  vulns: VulnInfo[];
  pkgs: PkgInfo[];
}

export class VulnerabilityLoader {
  // todo: Put in an SNS warning on failure
  static async loadVulnerabilities(dbPath: string): Promise<VulnReport> {
    const loadedData = await this.readVulnsFromDb(dbPath);
    // console.log(inspect(rebuiltVulns, { depth: 40 }));
    return this.rebuildVulns(loadedData);
  }

  private static async readVulnsFromDb(dbPath: string): Promise<GrypeData> {
    await promisifiedExec('grype db update');
    const db = await initDb(dbPath);

    const rawVulns = await db.all('SELECT * FROM vulnerability');
    const vulns = VulnCast.jsonBlobToVulnerabilities(rawVulns as Record<string, any>);

    const rawMeta = await db.all('SELECT * FROM vulnerability_metadata');
    const meta = MetaCast.jsonBlobToVulnerabilityMetadata(rawMeta as Record<string, any>);

    return { vulns, meta };
  }

  // Rebuilds the vulnerabilities, deduping them.  Adds the useful data from any duplicate vulns to the packages array
  private static rebuildVulns(loaded: GrypeData): VulnReport {
    const metaIndex = this.buildMetaIndex(loaded.meta);
    const vulnIndex: Record<string, any> = {};
    const pkgAggregator: PkgInfo[] = [];
    loaded.vulns.forEach((vulnItem) => {
      this.upsertVuln(vulnItem, metaIndex, vulnIndex, pkgAggregator);
    });
    return { vulns: Object.values(vulnIndex), pkgs: pkgAggregator };
  }

  private static upsertVuln(
    vulnItem: GrypeVuln,
    metaIndex: Record<string, GrypeMeta>,
    vulnIndex: Record<string, VulnInfo>,
    pkgAggregator: PkgInfo[]
  ) {
    const id_namespace = vulnItem.id + ':' + vulnItem.namespace;
    if (vulnIndex[id_namespace] === undefined) {
      const meta = metaIndex[id_namespace];
      if (!meta) {
        throw new Error('no metadata found for vuln ' + id_namespace);
      }
      const newVuln: VulnInfo = {
        name: vulnItem.id,
        namespace: vulnItem.namespace,
        name_namespaced: id_namespace,
        related_vulnerabilities: vulnItem.related_vulnerabilities,

        // info pulled in from metadata
        data_source: meta.data_source,
        record_source: meta.record_source,
        severity: meta.severity,
        urls: meta.urls,
        description: meta.description,
      };
      vulnIndex[id_namespace] = newVuln;
    }
    pkgAggregator.push(this.createPkgInfo(vulnItem));
  }

  private static createPkgInfo(vuln: GrypeVuln): PkgInfo {
    const pkg = {
      vulnerability_name_namespaced: vuln.id + ':' + vuln.namespace,
      pkg_name: vuln.package_name,
      version_constraint: vuln.version_constraint,
      version_format: vuln.version_format,
      fixed_in_versions: vuln.fixed_in_versions,
      fix_state: vuln.fix_state,
      cpes: vuln.cpes,
      advisories: vuln.advisories,
    };
    return pkg;
  }

  private static buildMetaIndex(meta: GrypeMeta[]) {
    const metaIndex: Record<string, GrypeMeta> = {};
    meta.forEach((metaItem) => {
      const indexKey = metaItem.id + ':' + metaItem.namespace;
      metaIndex[indexKey] = metaItem;
    });
    return metaIndex;
  }
}
