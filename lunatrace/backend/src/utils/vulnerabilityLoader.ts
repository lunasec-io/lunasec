/*
 * Copyright 2022 by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
// import {db} from '../database/db'
import { exec } from 'child_process';
import { promisify } from 'util';

import { Database, open } from 'sqlite';
import sqlite3 from 'sqlite3';

import { pgp } from '../database/db';
import { GrypeVuln, Convert as VulnCast } from '../types/grypeVulnerabilities';
import { GrypeMeta, Convert as MetaCast } from '../types/grypeVulnerabilityMetadata';
import { PkgInfo, PkgVersion, VulnInfo } from '../types/vulnInfo';

sqlite3.verbose();
type DbType = Database<sqlite3.Database, sqlite3.Statement>;

async function initDb(dbName: string): Promise<DbType> {
  return open({
    filename: dbName,
    driver: sqlite3.Database,
    mode: sqlite3.OPEN_READONLY,
  });
}

// import os from 'os'
const promisifiedExec = promisify(exec);

interface GrypeData {
  vulns: GrypeVuln[];
  meta: GrypeMeta[];
}

export interface VulnReport {
  vulns: VulnInfo[];
  pkgs: PkgInfo[];
  pkgVersions: PkgVersion[];
}

export class VulnerabilityLoader {
  // todo: Put in an SNS warning on failure
  static async loadVulnerabilities(dbPath: string): Promise<VulnReport> {
    const loadedData = await this.readVulnsFromDb(dbPath);
    // console.log(inspect(rebuiltVulns, { depth: 40 }));
    return this.rebuildVulns(loadedData);
  }

  private static async readVulnsFromDb(dbPath: string): Promise<GrypeData> {
    const { stdout, stderr } = await promisifiedExec('grype db update');
    console.log(stdout, stderr);
    const db = await initDb(dbPath);

    const rawVulns = await db.all('SELECT * FROM vulnerability');
    const vulns = VulnCast.jsonBlobToVulnerabilities(rawVulns as Record<string, any>);

    const rawMeta = await db.all('SELECT * FROM vulnerability_metadata');
    const meta = MetaCast.jsonBlobToVulnerabilityMetadata(rawMeta as Record<string, any>);

    return { vulns, meta };
  }

  // Rebuilds the vulnerabilities, deduping them.  Adds the useful data from any duplicate vulns to the indexes
  private static rebuildVulns(loaded: GrypeData): VulnReport {
    // init indexes
    const metaIndex = this.buildMetaIndex(loaded.meta);
    const vulnIndex: Record<string, any> = {};
    const pkgIndex: Record<string, PkgInfo> = {};
    const pkgVersionIndex: Record<string, PkgVersion> = {};
    // loop vulns, inserting them into index
    loaded.vulns.forEach((vulnItem) => {
      this.upsertVuln(vulnItem, metaIndex, vulnIndex, pkgIndex, pkgVersionIndex);
    });
    return {
      vulns: Object.values(vulnIndex),
      pkgs: Object.values(pkgIndex),
      pkgVersions: Object.values(pkgVersionIndex),
    };
  }

  private static upsertVuln(
    vulnItem: GrypeVuln,
    metaIndex: Record<string, GrypeMeta>,
    vulnIndex: Record<string, VulnInfo>,
    pkgIndex: Record<string, PkgInfo>,
    pkgVersionIndex: Record<string, PkgVersion>
  ) {
    const vulnSlug = vulnItem.id + ':' + vulnItem.namespace;
    if (vulnIndex[vulnSlug] === undefined) {
      const meta = metaIndex[vulnSlug];
      if (!meta) {
        throw new Error('no metadata found for vuln ' + vulnSlug);
      }

      const parsedUrls = JSON.parse(meta.urls);
      const urls = Array.isArray(parsedUrls) ? parsedUrls : [];

      const newVuln: VulnInfo = {
        name: vulnItem.id,
        namespace: vulnItem.namespace,
        slug: vulnSlug,
        related_vulnerabilities: vulnItem.related_vulnerabilities,

        // info pulled in from metadata
        data_source: meta.data_source,
        record_source: meta.record_source,
        severity: meta.severity,
        urls: urls,
        description: meta.description,
      };
      vulnIndex[vulnSlug] = newVuln;
    }
    this.storePkgInfo(vulnItem, pkgIndex, pkgVersionIndex);
  }

  private static storePkgInfo(
    vuln: GrypeVuln,
    pkgIndex: Record<string, PkgInfo>,
    pkgVersionIndex: Record<string, PkgVersion>
  ) {
    const pkgSlug = vuln.id + ':' + vuln.namespace + ':' + vuln.version_constraint;
    const prExisting = pkgIndex[pkgSlug];

    if (prExisting === undefined) {
      pkgIndex[pkgSlug] = {
        slug: pkgSlug,
        vuln_slug: vuln.id + ':' + vuln.namespace,
        name: vuln.package_name,
        advisories: vuln.advisories,
      };
    }
    this.storePkgVersionInfo(vuln, pkgVersionIndex);
  }

  private static storePkgVersionInfo(vuln: GrypeVuln, pkgVersionIndex: Record<string, PkgVersion>) {
    const versionSlug = vuln.id + ':' + vuln.namespace + ':' + vuln.package_name + ':' + vuln.version_constraint;
    const preExisting = pkgVersionIndex[versionSlug];

    // Merge CPEs
    const parsedCpes = JSON.parse(vuln.cpes);
    const newCpes = Array.isArray(parsedCpes) ? parsedCpes : [];
    const mergedCpes = preExisting ? preExisting.cpes.concat(newCpes) : newCpes;

    const newVersion = {
      version_constraint: vuln.version_constraint, // use this to dedup, overwriting and merging cpes
      version_format: vuln.version_format,
      fixed_in_versions: vuln.fixed_in_versions,
      fix_state: vuln.fix_state,
      cpes: mergedCpes,
      pkg_slug: vuln.id + ':' + vuln.namespace + ':' + vuln.package_name,
      slug: versionSlug,
    };

    pkgVersionIndex[versionSlug] = newVersion;
  }

  private static buildMetaIndex(meta: GrypeMeta[]) {
    const metaIndex: Record<string, GrypeMeta> = {};
    meta.forEach((metaItem) => {
      const indexKey = metaItem.id + ':' + metaItem.namespace;
      metaIndex[indexKey] = metaItem;
    });
    return metaIndex;
  }
}
