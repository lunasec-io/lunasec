-- Visual representation: https://dbdiagram.io/d/62a7ce3b9921fe2a96f9e2cb

-- TODO (cthompson) was not able to get this working, but possibly helpful if we want to avoid duplicated rows
-- In a many to many relationship, you can avoid duplicate insertions (ie. (a, b) and (b, a))
-- by only ever inserting a single pair of (a, b). To achieve this, the pair is ordered such that
-- a < b and then returned.
-- Example:
--   INSERT VALUES (2, 1) -> is 2 > 1? yes, reverse it so it is (1, 2)
--   INSERT VALUES (3, 4) -> is 3 > 4? no, return (3, 4)
-- CREATE FUNCTION many_to_many_sorted_insertion() RETURNS TRIGGER AS
-- $many_to_many_sorted_insertion$
-- BEGIN
--     -- Sort the row
--     IF NEW.a > NEW.b THEN
--         set_config('tmpuuid', NEW.a, TRUE);
--         NEW.a := NEW.b;
--         NEW.b := current_setting('tmpuuid');
--     END IF;
--
--     RETURN NEW;
-- END;
-- $many_to_many_sorted_insertion$ LANGUAGE plpgsql;

CREATE SCHEMA "vulnerability";

CREATE TYPE "public"."affected_version_type" AS ENUM (
    'git',
    'semver',
    'ecosystem'
);

CREATE TYPE "public"."reference_type" AS ENUM (
    'advisory',
    'article',
    'report',
    'fix',
    'git',
    'package',
    'web'
);

CREATE TABLE "vulnerability"."vulnerability" (
    "id" UUID PRIMARY KEY DEFAULT public.gen_random_uuid(),
    "source" text NOT NULL,
    "source_id" text NOT NULL,
    "modified" timestamptz NOT NULL DEFAULT (now()),
    "published" timestamptz,
    "withdrawn" timestamptz,
    "aliases" text[],
    "summary" text,
    "details" text,
    "database_specific" jsonb,
    "upstream_data" jsonb,
    CONSTRAINT vulnerability_source_source_id_idx UNIQUE ("source", "source_id")
);

CREATE TABLE "vulnerability"."equivalent" (
    "a" UUID REFERENCES "vulnerability"."vulnerability" ("id"),
    "b" UUID REFERENCES "vulnerability"."vulnerability" ("id"),
    CONSTRAINT equivalent_a_b_idx UNIQUE ("a", "b")
);

-- CREATE TRIGGER vulnerability_equivalent_many_to_many_sorted_insertion
--     BEFORE INSERT OR UPDATE
--     ON vulnerability.equivalent
--     FOR EACH ROW
-- EXECUTE FUNCTION many_to_many_sorted_insertion();

CREATE TABLE "vulnerability"."severity" (
    "id" UUID PRIMARY KEY DEFAULT public.gen_random_uuid(),
    "vulnerability_id" UUID REFERENCES "vulnerability"."vulnerability" ("id"),
    "source" text NOT NULL,
    "type" text NOT NULL,
    "score" text NOT NULL,
    CONSTRAINT severity_vulnerability_id_source_type_idx UNIQUE ("vulnerability_id", "source", "type")
);

CREATE TABLE "vulnerability"."affected" (
    "id" UUID PRIMARY KEY DEFAULT public.gen_random_uuid(),
    "vulnerability_id" UUID REFERENCES "vulnerability"."vulnerability" ("id"),
    "package_id" UUID NOT NULL,
    "ecosystem_specific" jsonb,
    "database_specific" jsonb,
    CONSTRAINT affected_vulnerability_id_package_id_idx UNIQUE ("vulnerability_id", "package_id")
);

CREATE TABLE "vulnerability"."affected_range_event" (
    "id" UUID PRIMARY KEY DEFAULT public.gen_random_uuid(),
    "affected_id" UUID REFERENCES "vulnerability"."affected" ("id"),
    "event" text NOT NULL,
    "version" text,
    "commit" text,
    "database_specific" jsonb,
    CONSTRAINT affected_range_event_affected_id_idx UNIQUE ("affected_id")
);

CREATE TABLE "vulnerability"."affected_version" (
    "id" UUID PRIMARY KEY DEFAULT public.gen_random_uuid(),
    "affected_id" UUID REFERENCES "vulnerability"."affected" ("id"),
    "type" affected_version_type NOT NULL,
    "version" text NOT NULL,
    "database_specific" jsonb,
    CONSTRAINT affected_version_affected_id_type_version UNIQUE ("affected_id", "type", "version")
);

CREATE TABLE "vulnerability"."reference" (
    "id" UUID PRIMARY KEY DEFAULT public.gen_random_uuid(),
    "vulnerability_id" UUID REFERENCES "vulnerability"."vulnerability" ("id"),
    "type" reference_type NOT NULL,
    "url" text NOT NULL,
    CONSTRAINT reference_vulnerability_id_type_url_idx UNIQUE ("vulnerability_id", "type", "url")
);

CREATE TABLE "vulnerability"."credit" (
    "id" UUID PRIMARY KEY DEFAULT public.gen_random_uuid(),
    "vulnerability_id" UUID REFERENCES "vulnerability"."vulnerability" ("id"),
    "name" text NOT NULL,
    "contact" text[],
    CONSTRAINT credit_vulnerability_id_name UNIQUE ("vulnerability_id", "name")
);
