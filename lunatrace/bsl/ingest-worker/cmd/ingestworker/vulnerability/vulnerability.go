// Copyright by LunaSec (owned by Refinery Labs, Inc)
//
// Licensed under the Business Source License v1.1
// (the "License"); you may not use this file except in compliance with the
// License. You may obtain a copy of the License at
//
// https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
package vulnerability

import (
	"context"
	"github.com/lunasec-io/lunasec/lunatrace/cli/pkg/util"
	"github.com/rs/zerolog/log"
	"io/ioutil"
	"path"

	"github.com/urfave/cli/v2"
	"go.uber.org/fx"

	"github.com/lunasec-io/lunasec/lunatrace/bsl/ingest-worker/pkg/vulnerability"

	"github.com/ajvpot/clifx"
)

type Params struct {
	fx.In

	Ingester vulnerability.FileAdvisoryIngester
}

func NewCommand(p Params) clifx.CommandResult {
	return clifx.CommandResult{
		Command: &cli.Command{
			Name: "vulnerability",
			Subcommands: []*cli.Command{
				{
					Name:  "ingest",
					Usage: "[file or directory]",
					Flags: []cli.Flag{
						&cli.StringFlag{
							Name:     "source",
							Usage:    "Where the vulnerabilities have been sourced from.",
							Required: true,
						},
						&cli.StringFlag{
							Name:  "source-relative-path",
							Usage: "Relative path from within the source to where advisories are located.",
						},
					},
					Subcommands: []*cli.Command{},
					Action: func(ctx *cli.Context) error {
						var err error

						source := ctx.String("source")
						sourceRelativePath := ctx.String("source-relative-path")

						advisoryLocation := ctx.Args().First()
						if advisoryLocation == "" {
							advisoryLocation, err = ioutil.TempDir("", source+"-advisories")
							if err != nil {
								log.Error().
									Err(err).
									Msg("unable to create temporary directory for advisories")
								return err
							}
							util.EnsureDirIsCleanedUp(advisoryLocation)

							log.Info().
								Str("source", source).
								Msg("pulling advisories from source")

							err = vulnerability.PullVulnerabilitiesFromSource(source, advisoryLocation)
							if err != nil {
								log.Error().
									Err(err).
									Msg("unable to pull vulnerabilities from source")
								return err
							}

							log.Info().
								Str("source", source).
								Msg("collected advisories from source")
						}

						if sourceRelativePath != "" {
							advisoryLocation = path.Join(advisoryLocation, sourceRelativePath)
						}

						ingestCtx := context.Background()
						return p.Ingester.Ingest(ingestCtx, source, advisoryLocation)
					},
				},
			},
		},
	}
}
