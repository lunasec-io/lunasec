/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
// import {db} from '../database/db'
import { exec } from 'child_process';
import { promisify } from 'util';

import { Database, open } from 'sqlite';
import sqlite3 from 'sqlite3';

import { Convert as CvssCast, GrypeCvss } from '../types/grype-cvss';
import { GrypeVuln, Convert as VulnCast } from '../types/grype-vulnerabilities';
import { GrypeMeta, Convert as MetaCast } from '../types/grype-vulnerability-metadata';
import { CvssColumns, PkgInfo, PkgVersion, RelatedVulnerability, VulnInfo, VulnWithoutCvss } from '../types/vulnInfo';

import {log} from "./log";

sqlite3.verbose();
export type DbType = Database<sqlite3.Database, sqlite3.Statement>;

export async function initDb(dbName: string): Promise<DbType> {
  return open({
    filename: dbName,
    driver: sqlite3.Database,
    mode: sqlite3.OPEN_READONLY,
  });
}

// import os from 'os'
const promisifiedExec = promisify(exec);

interface GrypeData {
  vulns: GrypeVuln[];
  meta: GrypeMeta[];
}

export interface VulnReport {
  vulns: VulnInfo[];
  pkgs: PkgInfo[];
  pkgVersions: PkgVersion[];
  relatedVulnerabilities: RelatedVulnerability[];
}

export class VulnerabilityLoader {
  // todo: Put in an SNS warning on failure
  metaIndex: Record<string, GrypeMeta> = {};
  vulnIndex: Record<string, any> = {};
  pkgIndex: Record<string, PkgInfo> = {};
  pkgVersionIndex: Record<string, PkgVersion> = {};
  relatedVulnerabilities: RelatedVulnerability[] = [];
  dbPath: string;

  constructor(dbPath: string) {
    this.dbPath = dbPath;
  }

  async loadVulnerabilities(): Promise<VulnReport> {
    const loadedData = await this.readVulnsFromDb(this.dbPath);
    // log.info(inspect(rebuiltVulns, { depth: 40 }));
    return this.rebuildVulns(loadedData);
  }

  public async readVulnsFromDb(dbPath: string): Promise<GrypeData> {
    const { stdout, stderr } = await promisifiedExec('grype db update');
    log.info(stdout, stderr);
    const db = await initDb(dbPath);

    const rawVulns = await db.all('SELECT * FROM vulnerability');
    const vulns = VulnCast.jsonBlobToVulnerabilities(rawVulns as Record<string, any>);

    const rawMeta = await db.all('SELECT * FROM vulnerability_metadata');
    const meta = MetaCast.jsonBlobToVulnerabilityMetadata(rawMeta as Record<string, any>);

    return { vulns, meta };
  }

  // Rebuilds the vulnerabilities, deduping them.  Adds the useful data from any duplicate vulns to the indexes
  private rebuildVulns(loaded: GrypeData): VulnReport {
    // init indexes
    this.buildMetaIndex(loaded.meta);
    // loop vulns, inserting them into index
    loaded.vulns.forEach((vulnItem) => {
      this.upsertVuln(vulnItem);
    });
    // build a map of related vulnerabilities
    this.storeRelatedVulnerabilities(loaded.vulns);

    return {
      vulns: Object.values(this.vulnIndex),
      pkgs: Object.values(this.pkgIndex),
      pkgVersions: Object.values(this.pkgVersionIndex),
      relatedVulnerabilities: this.relatedVulnerabilities,
    };
  }

  private upsertVuln(vulnItem: GrypeVuln) {
    const vulnSlug = vulnItem.id + ':' + vulnItem.namespace;
    if (this.vulnIndex[vulnSlug] === undefined) {
      const meta = this.metaIndex[vulnSlug];
      if (!meta) {
        throw new Error('no metadata found for vuln ' + vulnSlug);
      }

      const newVuln: VulnWithoutCvss = {
        name: vulnItem.id,
        namespace: vulnItem.namespace,
        slug: vulnSlug,

        // info pulled in from metadata
        data_source: meta.data_source,
        record_source: meta.record_source,
        severity: meta.severity,
        urls: this.parseToArray(meta.urls),
        description: meta.description,
      };
      const newVulnWithCvss: VulnInfo = this.addCvssScoreToVuln(vulnItem, meta, newVuln);
      this.vulnIndex[vulnSlug] = newVulnWithCvss;
    }
    this.storePkgInfo(vulnItem, vulnSlug);
  }

  private storePkgInfo(vuln: GrypeVuln, vulnSlug: string) {
    const pkgSlug = vulnSlug + ':' + vuln.package_name; // dedup on package name
    const preExisting = this.pkgIndex[pkgSlug];

    if (preExisting === undefined) {
      this.pkgIndex[pkgSlug] = {
        slug: pkgSlug,
        vuln_slug: vulnSlug,
        name: vuln.package_name,
        advisories: vuln.advisories,
      };
    }
    this.storePkgVersionInfo(vuln, pkgSlug);
  }

  private storePkgVersionInfo(vuln: GrypeVuln, pkgSlug: string) {
    const versionSlug = pkgSlug + ':' + vuln.version_constraint; // dedup on version constraint
    const preExisting = this.pkgVersionIndex[versionSlug];

    // Merge CPEs
    const newCpes = this.parseToArray<string>(vuln.cpes);
    const mergedCpes = preExisting ? preExisting.cpes.concat(newCpes) : newCpes;

    const newVersion = {
      version_constraint: vuln.version_constraint,
      version_format: vuln.version_format,
      fixed_in_versions: this.parseToArray<string>(vuln.fixed_in_versions),
      fix_state: vuln.fix_state,
      cpes: mergedCpes,
      pkg_slug: pkgSlug,
      slug: versionSlug,
    };
    if (!this.pkgIndex[pkgSlug]) {
      throw new Error('pkg version missing package to attach to ' + pkgSlug + ' ' + versionSlug);
    }

    this.pkgVersionIndex[versionSlug] = newVersion;
  }

  private buildMetaIndex(meta: GrypeMeta[]) {
    meta.forEach((metaItem) => {
      const indexKey = metaItem.id + ':' + metaItem.namespace;
      this.metaIndex[indexKey] = metaItem;
    });
  }

  // builds an array of all the vulnerability relations, without deduping because we just let postgres handle it with a UNIQUE()
  private storeRelatedVulnerabilities(vulns: GrypeVuln[]) {
    vulns.forEach((vuln) => {
      const related = this.parseToArray<{ ID: string; Namespace: string }>(vuln.related_vulnerabilities);
      related.forEach((related) => {
        const vulnSlug = vuln.id + ':' + vuln.namespace;
        const relatedSlug = related.ID + ':' + related.Namespace;
        // Some of these link to a vuln we dont have, violating foreign key constraint. So we eliminate those
        if (this.vulnIndex[relatedSlug]) {
          this.relatedVulnerabilities.push({ vulnerability_slug: vulnSlug, related_vulnerability_slug: relatedSlug });
        }
      });
    });
  }

  // in these CVSS functions, we try to determine if the vuln has a CVSS score, and failing that, try to find a linked NVD
  // vuln with a score we can use
  private addCvssScoreToVuln(vuln: GrypeVuln, meta: GrypeMeta, newVuln: VulnWithoutCvss): VulnInfo {
    // quick way to skip strings of '[] ' empty array
    const parsedScores = CvssCast.toGrypeCvss(meta.cvss);
    if (parsedScores.length > 0) {
      return Object.assign({}, newVuln, this.convertCvss(parsedScores, false));
    }
    // Otherwise try to infer a CVSS if this vuln is linked to once single other NVD vuln
    const relateds = this.parseToArray<{ ID: string; Namespace: string }>(vuln.related_vulnerabilities);
    const relatedNvds = relateds.filter((r) => r.Namespace === 'nvd');
    // if there are multiple nvds or no nvds give up
    if (relatedNvds.length !== 1) {
      return this.mergeVulnAndCvss(newVuln, null);
    }
    const nvdSlug = relatedNvds[0].ID + ':' + relatedNvds[0].Namespace;
    const nvdVulnMeta = this.metaIndex[nvdSlug];
    if (!nvdVulnMeta) {
      return this.mergeVulnAndCvss(newVuln, null);
    }
    const parsedRelatedScores = CvssCast.toGrypeCvss(nvdVulnMeta.cvss);
    if (!parsedRelatedScores) {
      return this.mergeVulnAndCvss(newVuln, null);
    }
    return this.mergeVulnAndCvss(newVuln, this.convertCvss(parsedRelatedScores, true));
  }

  // Because of the way that the pg-promise library works, we must put null values into the cvss props
  private mergeVulnAndCvss(vuln: VulnWithoutCvss, cvssInfo: CvssColumns | null): VulnInfo {
    const nullCvss: CvssColumns = {
      cvss_version: null,
      cvss_score: null,
      cvss_exploitability_score: null,
      cvss_impact_score: null,
      cvss_inferred: null,
    };
    return Object.assign({}, vuln, cvssInfo || nullCvss);
  }

  private convertCvss(parsedScores: GrypeCvss[], inferred: boolean): CvssColumns | null {
    if (!parsedScores || parsedScores.length < 1) {
      return null;
    }
    const score = parsedScores.sort((a, b) => (a.Version < b.Version ? 1 : -1))[0];
    return {
      cvss_version: score.Version,
      cvss_score: score.Metrics.BaseScore,
      cvss_exploitability_score: score.Metrics.ExploitabilityScore,
      cvss_impact_score: score.Metrics.ImpactScore,
      cvss_inferred: inferred,
    };
  }

  private parseToArray<t>(jsonString: string): t[] {
    try {
      const a = JSON.parse(jsonString);
      return Array.isArray(a) ? (a as t[]) : [];
    } catch (e) {
      log.info('caught error when parsing cvss string ', e);
      return [];
    }
  }
}
