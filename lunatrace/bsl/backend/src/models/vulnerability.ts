/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import { createReadStream } from 'fs';
import os from 'os';
import path from 'path';

import { PutObjectCommand, S3Client } from '@aws-sdk/client-s3';
import { defaultProvider } from '@aws-sdk/credential-provider-node';

import { getAwsConfig, getVulnerabilityUpdateConfig } from '../config';
import { db, pgp } from '../database/db';
import { PkgInfo, PkgVersion, RelatedVulnerability, VulnInfo } from '../types/vulnInfo';
import { log } from '../utils/log';
import { VulnerabilityLoader } from '../utils/vulnerability-loader';

function* chunks<T>(arr: T[], n: number) {
  for (let i = 0; i < arr.length; i += n) {
    yield arr.slice(i, i + n);
  }
}

export class Vulnerability {
  static async updateVulnDb() {
    log.info('beginning vuln update');
    const grypeDbPath = path.join(os.homedir(), '.cache/grype/db/3/vulnerability.db');

    const vulnLoader = new VulnerabilityLoader(grypeDbPath);

    const { vulns, pkgs, pkgVersions, relatedVulnerabilities } = await vulnLoader.loadVulnerabilities();

    log.info('loaded vulns from grype sqlite', {
      count: vulns.length,
      pkgs: pkgs.length,
      pkgVersions: pkgVersions.length,
      relatedVulnerabilities: relatedVulnerabilities.length,
    });

    const awsConfig = getAwsConfig();
    const updateVulnerabilityConfig = getVulnerabilityUpdateConfig();

    const today = new Date();

    const key = `${today.getFullYear()}/${today.getMonth()}/${today.getDay()}/${today.getHours()}/vulnerability.db`;

    const readStream = createReadStream(grypeDbPath);

    const s3Client = new S3Client({ region: awsConfig.awsRegion, credentials: defaultProvider() });
    const command = new PutObjectCommand({
      Key: key,
      Bucket: updateVulnerabilityConfig.grypeDatabaseBucket,
      Body: readStream,
    });

    try {
      const response = await s3Client.send(command);
      const code = response.$metadata.httpStatusCode;
      if (!code || code > 299) {
        log.warn('unable to upload grype database to s3', {
          db: grypeDbPath,
          bucket: updateVulnerabilityConfig.grypeDatabaseBucket,
          key: key,
          code: code,
          resp: response,
        });
      } else {
        log.info('saved latest grype database to s3', {
          bucket: updateVulnerabilityConfig.grypeDatabaseBucket,
          key: key,
        });
      }
    } catch (e) {
      log.warn('unable to upload grype database to s3');
    }

    // TODO move to dedicated sql files
    // do NOT use template strings

    let success = false;

    for (let i = 0; i < 10; i++) {
      try {
        log.info('Beginning DB Transaction...');

        await db.tx(async (t) => {
          await t.none('SET statement_timeout = 1000000000;');
          for (const q of this.buildVulnQueries(vulns)) {
            await t.none(q);
          }
          for (const q of this.buildPkgsInsertQueries(pkgs)) {
            await t.none(q);
          }
          for (const q of this.buildPkgVersionInsertQueries(pkgVersions)) {
            await t.none(q);
          }
          for (const q of this.buildRelatedVulnerabilityQueries(relatedVulnerabilities)) {
            await t.none(q);
          }

          log.info('Flushing DB Transaction...');
        });

        log.info('Successfully wrote to DB');
        success = true;
        break;
      } catch (e) {
        log.info('Error writing to DB, waiting 1 minute:', e);
        await delay(60000);
        log.info('Retrying...');
        continue;
      }
    }

    if (success === false) {
      log.error('Failed to write to DB');
      throw new Error('Unable to update vulnerability database');
    }

    log.info('Completed updating vulnerability database');
  }

  private static *buildVulnQueries(vulns: VulnInfo[]) {
    for (const qs of chunks(vulns, 500)) {
      const columns = new pgp.helpers.ColumnSet(
        [
          'name',
          'namespace',
          'slug',
          'data_source',
          'record_source',
          'severity',
          'urls',
          'description',
          'cvss_version',
          'cvss_score',
          'cvss_exploitability_score',
          'cvss_impact_score',
          'cvss_inferred',
        ],
        { table: 'vulnerabilities' }
      );
      const insertQuery = pgp.helpers.insert(qs, columns);
      yield insertQuery.concat(` ON CONFLICT (slug) DO UPDATE
                        SET
                            data_source = EXCLUDED.data_source,
                            record_source = EXCLUDED.record_source,
                            severity = EXCLUDED.severity,
                            urls = EXCLUDED.urls,
                            description = EXCLUDED.description,
                            cvss_version = EXCLUDED.cvss_version,
                            cvss_score = EXCLUDED.cvss_score,
                            cvss_exploitability_score = EXCLUDED.cvss_exploitability_score,
                            cvss_impact_score = EXCLUDED.cvss_impact_score,
                            cvss_inferred = EXCLUDED.cvss_inferred
                        `);
    }
  }

  private static *buildPkgsInsertQueries(pkgs: PkgInfo[]) {
    for (const qs of chunks(pkgs, 500)) {
      const columns = new pgp.helpers.ColumnSet(['slug', 'vuln_slug', 'name', 'advisories'], {
        table: 'vulnerability_packages',
      });
      const query = pgp.helpers.insert(qs, columns);
      yield query.concat(`ON CONFLICT (slug) DO UPDATE 
      SET 
        advisories = EXCLUDED.advisories
    `);
    }
  }

  private static *buildPkgVersionInsertQueries(pkgVersions: PkgVersion[]) {
    for (const qs of chunks(pkgVersions, 500)) {
      const columns = new pgp.helpers.ColumnSet(
        ['slug', 'version_constraint', 'version_format', 'fixed_in_versions', 'fix_state', 'cpes', 'pkg_slug'],
        {
          table: 'package_versions',
        }
      );
      const query = pgp.helpers.insert(qs, columns);
      yield query.concat(
        `ON CONFLICT (slug) DO UPDATE 
      SET 
        version_format = EXCLUDED.version_format, 
        fixed_in_versions = EXCLUDED.fixed_in_versions,
        fix_state = EXCLUDED.fix_state,
        cpes = EXCLUDED.cpes
      `
      );
    }
  }

  private static *buildRelatedVulnerabilityQueries(related: RelatedVulnerability[]) {
    if (related.length === 0) {
      return;
    }
    for (const qs of chunks(related, 500)) {
      const columns = new pgp.helpers.ColumnSet(['vulnerability_slug', 'related_vulnerability_slug'], {
        table: 'related_vulnerabilities',
      });
      const query = pgp.helpers.insert(qs, columns);
      yield query.concat('ON CONFLICT DO NOTHING');
    }
  }
}

function delay(timeout: number) {
  return new Promise((resolve) => setTimeout(resolve, timeout));
}
