/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import os from 'os';
import path from 'path';
import process from 'process';

import { db, pgp } from '../database/db';
import { PkgInfo, PkgVersion, RelatedVulnerability, VulnInfo } from '../types/vulnInfo';
import { log } from '../utils/log';
import { VulnerabilityLoader } from '../utils/vulnerability-loader';


export class Vulnerability {
  static async updateVulnDb() {
    log.info('beginning vuln update');
    const onMac = process.platform === "darwin";
    const relativeDbPath = onMac ? 'Library/Caches/grype/db/3/vulnerability.db': '.cache/grype/db/3/vulnerability.db'
    const grypeDbPath = path.join(os.homedir(), relativeDbPath);

    const vulnLoader = new VulnerabilityLoader(grypeDbPath);

    const { vulns, pkgs, pkgVersions, relatedVulnerabilities } = await vulnLoader.loadVulnerabilities();

    log.info('loaded ', vulns.length, ' vulns from grype sqlite');
    log.info('and ', pkgs.length, ' pkgs');
    log.info('and ', pkgVersions.length, ' pkgVersions');
    log.info('and ', relatedVulnerabilities.length, ' relatedVulnerabilities');
    // todo: move to dedicated sql files
    // do NOT use template strings
    const vulnUpsertQuery = this.buildVulnQuery(vulns);

    let success = false;

    for (let i = 0; i < 10; i++) {
      try {
        log.info('Beginning DB Transaction...');
        await db.tx((t) => {
          const batch: Promise<null>[] = [];

          batch.push(t.none('SET statement_timeout = 1000000000;'));

          const vulnUpsert = t.none(vulnUpsertQuery);
          batch.push(vulnUpsert);

          const pkgInsertQuery = this.buildPkgsInsertQuery(pkgs);
          const insertPkgs = t.none(pkgInsertQuery);
          batch.push(insertPkgs);

          const pkgVersionInsertQuery = this.buildPkgVersionInsertQuery(pkgVersions);
          const insertPkgVersions = t.none(pkgVersionInsertQuery);
          batch.push(insertPkgVersions);

          const relatedInsertQuery = this.buildRelatedVulnerabilityQuery(relatedVulnerabilities);
          if (relatedInsertQuery) {
            const insertRelated = t.none(relatedInsertQuery);
            batch.push(insertRelated);
          }

          log.info('Flushing DB Transaction...');
          return t.batch(batch);
        });

        log.info('Successfully wrote to DB');
        success = true;
        break;
      } catch (e) {
        log.info('Error writing to DB, waiting 1 minute:', e);
        await delay(60000);
        log.info('Retrying...');
        continue;
      }
    }

    if (success === false) {
      log.error('Failed to write to DB');
      throw new Error('Unable to update vulnerability database');
    }

    log.info('donezo');
  }

  private static buildVulnQuery(vulns: VulnInfo[]): string {
    const columns = new pgp.helpers.ColumnSet(
      [
        'name',
        'namespace',
        'slug',
        'data_source',
        'record_source',
        'severity',
        'urls',
        'description',
        'cvss_version',
        'cvss_score',
        'cvss_exploitability_score',
        'cvss_impact_score',
        'cvss_inferred',
      ],
      { table: 'vulnerabilities' }
    );
    const insertQuery = pgp.helpers.insert(vulns, columns);
    return insertQuery.concat(` ON CONFLICT (slug) DO UPDATE
                        SET
                            data_source = EXCLUDED.data_source,
                            record_source = EXCLUDED.record_source,
                            severity = EXCLUDED.severity,
                            urls = EXCLUDED.urls,
                            description = EXCLUDED.description,
                            cvss_version = EXCLUDED.cvss_version,
                            cvss_score = EXCLUDED.cvss_score,
                            cvss_exploitability_score = EXCLUDED.cvss_exploitability_score,
                            cvss_impact_score = EXCLUDED.cvss_impact_score,
                            cvss_inferred = EXCLUDED.cvss_inferred
                        `);
  }

  private static buildPkgsInsertQuery(pkgs: PkgInfo[]): string {
    const columns = new pgp.helpers.ColumnSet(['slug', 'vuln_slug', 'name', 'advisories'], {
      table: 'vulnerability_packages',
    });
    const query = pgp.helpers.insert(pkgs, columns);
    return query.concat(`ON CONFLICT (slug) DO UPDATE 
      SET 
        advisories = EXCLUDED.advisories
    `);
  }

  private static buildPkgVersionInsertQuery(pkgVersions: PkgVersion[]): string {
    const columns = new pgp.helpers.ColumnSet(
      ['slug', 'version_constraint', 'version_format', 'fixed_in_versions', 'fix_state', 'cpes', 'pkg_slug'],
      {
        table: 'package_versions',
      }
    );
    const query = pgp.helpers.insert(pkgVersions, columns);
    return query.concat(
      `ON CONFLICT (slug) DO UPDATE 
      SET 
        version_format = EXCLUDED.version_format, 
        fixed_in_versions = EXCLUDED.fixed_in_versions,
        fix_state = EXCLUDED.fix_state,
        cpes = EXCLUDED.cpes
      `
    );
  }

  private static buildRelatedVulnerabilityQuery(related: RelatedVulnerability[]) {
    if (related.length === 0) {
      return;
    }

    const columns = new pgp.helpers.ColumnSet(['vulnerability_slug', 'related_vulnerability_slug'], {
      table: 'related_vulnerabilities',
    });
    const query = pgp.helpers.insert(related, columns);
    return query.concat('ON CONFLICT DO NOTHING');
  }
}

function delay(timeout: number) {
  return new Promise((resolve) => setTimeout(resolve, timeout));
}
