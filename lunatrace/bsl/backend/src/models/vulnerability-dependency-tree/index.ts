/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import { randomUUID } from 'crypto';

import { SeverityNamesOsv } from '@lunatrace/lunatrace-common/build/main';

import { Analysis_Finding_Type_Enum } from '../../hasura-api/generated';
import { notEmpty } from '../../utils/predicates';

import { Graph } from './graph';
import {
  DependencyChain,
  IgnoredVulnerability,
  Manifest,
  ManifestNode,
  TriagedPackageVulnerability,
  VulnerableEdge,
  VulnerableRelease,
} from './types';
import {
  createOrMergeVulnerablePackageRelease,
  isReleaseTriviallyUpdateable,
  VulnerabilityLoader,
} from './vulnerabilities';

const rootNode = '00000000-0000-0000-0000-000000000000';
const nilEdge = '00000000-0000-0000-0000-000000000000';

export default class VulnerabilityDependencyTree {
  public readonly graph: Graph;
  private packageReleaseIdToTriagedVulnerabilities: Map<string, TriagedPackageVulnerability[]> = new Map();
  private nodeIdToNode: Map<string, ManifestNode> = new Map();
  private vulnerableNodeIds: Set<string> = new Set();
  private nodeReachability: Map<string, Analysis_Finding_Type_Enum> = new Map();

  constructor(
    sourceManifests: Array<Manifest>,
    ignoredVulnerabilities?: IgnoredVulnerability[],
    minimumSeverity?: SeverityNamesOsv
  ) {
    this.graph = new Graph();

    const vulnLoader = new VulnerabilityLoader(ignoredVulnerabilities || [], minimumSeverity || 'Unknown');

    sourceManifests.forEach((manifest) => {
      manifest.child_edges_recursive?.forEach((edge) => {
        const node = edge.child;
        const childId = edge.child_id;
        const parentId = edge.parent_id;

        this.nodeIdToNode.set(childId, node);

        const packageReleaseVulnerabilities = vulnLoader.loadPackageReleaseVulnerabilities(
          node,
          manifest.path || 'Unknown'
        );

        // get existing vulnerabilities for a release, and extend them to include the newly built release vulnerabilities
        const existingReleaseVulnerabilities = this.packageReleaseIdToTriagedVulnerabilities.get(node.release_id);
        this.packageReleaseIdToTriagedVulnerabilities.set(
          node.release_id,
          existingReleaseVulnerabilities
            ? existingReleaseVulnerabilities.concat(packageReleaseVulnerabilities)
            : packageReleaseVulnerabilities
        );

        if (packageReleaseVulnerabilities.length > 0) {
          this.vulnerableNodeIds.add(childId); // dupes will be handled by the Set
        }

        /*
         find analysis results proving that a path is "not vulnerable" or "not reachable". in other words, we say a node is
         _not_ reachable _only_ when we have explicit analysis results that say that it is not reachable.
         */
        const reachable =
          edge.analysis_results.length > 0 ? edge.analysis_results[0].finding_type : Analysis_Finding_Type_Enum.Unknown;
        this.nodeReachability.set(childId, reachable);

        // TODO (cthompson) the recursive query should return a non-nil edge
        const edgeId = edge.id === nilEdge ? randomUUID() : edge.id;

        this.graph.insertEdge(edgeId, parentId, childId);
      });
    });
  }

  private allDependencyPathsToNodeId(nodeId: string): string[][] {
    const chainsToTraverse: string[][] = [];

    this.graph.getParentIds(nodeId).forEach((parent) => chainsToTraverse.push([parent, nodeId]));

    const dependencyChains = [];
    while (chainsToTraverse.length > 0) {
      const chain = chainsToTraverse.pop();
      if (!chain) {
        continue;
      }

      if (chain[0] === rootNode) {
        dependencyChains.push([rootNode, ...chain]);
        continue;
      }
      const parentNodes = this.graph.getParentIds(chain[0]);
      parentNodes.forEach((parentNode) => chainsToTraverse.push([parentNode, ...chain]));
    }
    return dependencyChains;
  }

  public getEdgesWhereChildIsVulnerable(): VulnerableEdge[] {
    const vulnerableEdges: VulnerableEdge[] = [];

    this.vulnerableNodeIds.forEach((childId) => {
      const node = this.nodeIdToNode.get(childId);
      if (!node) {
        return;
      }
      const vulnerabilityIds = node.release.package.affected_by_vulnerability.map((v) => v.vulnerability.id);
      this.graph.getNodeEdgeIds(childId).forEach((edgeId) => {
        if (edgeId === nilEdge) {
          return;
        }
        vulnerableEdges.push({
          edgeId,
          vulnerabilityIds,
        });
      });
    });
    return vulnerableEdges;
  }

  private getVulnerableDependencyChainsForNode(nodeId: string, singleReachableChain?: boolean): DependencyChain[] {
    const chainIdStrings = this.allDependencyPathsToNodeId(nodeId);

    let addedReachableChain = false;
    let addedNotReachableChain = false;
    const dependencyChains: DependencyChain[] = [];
    for (const chain of chainIdStrings) {
      const depChain = chain
        .map((nodeId) => {
          const node = this.nodeIdToNode.get(nodeId);
          const reachable = this.nodeReachability.get(nodeId);
          if (!node) {
            return null;
          }
          return {
            ...node,
            reachable: reachable || Analysis_Finding_Type_Enum.Unknown,
          };
        })
        .filter(notEmpty);

      const isNotReachableChain = !depChain.some((d) => d.reachable === Analysis_Finding_Type_Enum.NotVulnerable);

      /*
       If we only want to show a single chain to demonstrate the capabilities of the dependency chain view, then we
        1) determine if the chain is reachable or not
        2) see if we have added a reachable/non-reachable chain already
        3) once we have added both types of chains, then return to save some time
       */
      if (singleReachableChain) {
        if (isNotReachableChain && !addedNotReachableChain) {
          dependencyChains.push(depChain);
          addedNotReachableChain = true;
        }
        if (!isNotReachableChain && !addedReachableChain) {
          dependencyChains.push(depChain);
          addedReachableChain = true;
        }
        if (addedReachableChain && addedNotReachableChain) {
          return dependencyChains;
        }
      }
    }
    return dependencyChains;
  }

  public getVulnerableReleases(singleReachableChain?: boolean): VulnerableRelease[] {
    const vulnerableReleasesById: Map<string, VulnerableRelease> = new Map();

    this.vulnerableNodeIds.forEach((nodeId) => {
      const node = this.nodeIdToNode.get(nodeId);
      if (!node) {
        return;
      }

      const packageReleaseVulnerabilities = this.packageReleaseIdToTriagedVulnerabilities.get(node.release_id);
      if (!packageReleaseVulnerabilities) {
        return;
      }

      const triviallyUpdatable = isReleaseTriviallyUpdateable(packageReleaseVulnerabilities);

      const chains = this.getVulnerableDependencyChainsForNode(nodeId, singleReachableChain);

      const devOnly = chains.every((chain) => {
        if (chain.length === 0) {
          return false;
        }

        const node = chain[0];
        return node.labels && node.labels.scope === 'dev';
      });

      // loop each vulnerability on the node
      packageReleaseVulnerabilities.forEach((releaseVulnerability, index) => {
        const existingRelease = vulnerableReleasesById.get(node.release_id);
        const isFirstVulnOnNode = index === 0;

        const upsertedRelease = createOrMergeVulnerablePackageRelease(
          existingRelease,
          node.release,
          releaseVulnerability,
          isFirstVulnOnNode ? chains : [],
          devOnly,
          triviallyUpdatable
        );
        vulnerableReleasesById.set(node.release_id, upsertedRelease);
      });
    });
    return Array.from(vulnerableReleasesById.values());
  }
}
