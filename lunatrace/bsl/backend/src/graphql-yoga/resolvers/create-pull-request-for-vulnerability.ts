/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import { GraphQLYogaError } from '@graphql-yoga/node';
import {
  PullRequestOctokit,
  replacePackageAndFileGitHubPullRequest,
} from '@lunatrace/npm-package-cli/src/package/github-pr';

import { getInstallationAccessToken } from '../../github/auth';
import { hasura } from '../../hasura-api';
import { log } from '../../utils/log';
import { MutationResolvers } from '../generated-resolver-types';
import { checkProjectIsAuthorizedOrThrow, isAuthenticated } from '../helpers/auth-helpers';

type CreatePullRequestForVulnerabilityType = NonNullable<MutationResolvers['createPullRequestForVulnerability']>;

function splitGitHubRepoPath(gitHubRepo: string) {
  // URL from GitHub of the repo, eg: git://github.com/lunasec-io/lunasec.git
  const split = gitHubRepo.split('/');
  const owner = split[split.length - 2];
  const repo = split[split.length - 1].replace('.git', '');
  return { owner, repo };
}

/**
 * Installs the repos the user selected in the GUIG
 */
export const createPullRequestForVulnerabilityResolver: CreatePullRequestForVulnerabilityType = async (
  parent,
  args,
  ctx,
  _info
) => {
  try {
    if (!isAuthenticated(ctx)) {
      log.warn('No parsed JWT claims with a user ID on route that required authorization, throwing a graphql error');
      throw new GraphQLYogaError('Unauthorized');
    }

    const vulnerabilityId = args.vulnerability_id;
    if (!vulnerabilityId) {
      throw new GraphQLYogaError('No vulnerability id provided');
    }

    const projectId = args.project_id;
    if (!projectId) {
      throw new GraphQLYogaError('No project id provided');
    }

    const oldPackageSlug = args.old_package_slug;
    if (!oldPackageSlug) {
      throw new GraphQLYogaError('No old package slug provided');
    }

    const newPackageSlug = args.new_package_slug;
    if (!newPackageSlug) {
      throw new GraphQLYogaError('No new package slug provided');
    }

    const packageManifestPath = args.package_manifest_path;
    if (!packageManifestPath) {
      throw new GraphQLYogaError('No package manifest path provided');
    }

    // Strips out the actual package.json/yarn.lock/package-lock.json from the path since we just need the folder.
    const normalizedPackageManifestPath = packageManifestPath
      .replace(/package\.json$/, '')
      .replace(/yarn\.lock$/, '')
      .replace(/package-lock\.json$/, '');

    await checkProjectIsAuthorizedOrThrow(projectId, ctx);

    const installationIdResult = await hasura.GetGitHubInstallationIdFromProjectId({
      project_id: projectId,
    });

    if (installationIdResult.projects.length === 0) {
      throw new GraphQLYogaError('No project found when fetching installation id');
    }

    const installationId = installationIdResult.projects[0].organization?.installation_id;

    if (!installationId) {
      throw new GraphQLYogaError('No installation id found for project');
    }

    const githubRepo = installationIdResult.projects[0].github_repository?.git_url;

    if (!githubRepo) {
      throw new GraphQLYogaError('No github repo found for project');
    }

    const { owner, repo } = splitGitHubRepoPath(githubRepo);

    const installationAccessTokenRes = await getInstallationAccessToken(installationId);
    if (installationAccessTokenRes.error) {
      log.error('Failed to fetch installation access token', { installationAccessTokenRes });
      throw new Error('Error fetching installation access token');
    }

    const installationAccessToken = installationAccessTokenRes.res;

    const octokit = new PullRequestOctokit({
      auth: installationAccessToken,
    });

    const pullRequestResult = await replacePackageAndFileGitHubPullRequest(
      octokit,
      owner,
      repo,
      normalizedPackageManifestPath,
      // TODO: Make this less hacky and brittle
      packageManifestPath.endsWith('package-lock.json') ? 'npm' : 'yarn',
      oldPackageSlug,
      newPackageSlug
    );

    // TODO: Actually implement this endpoint instead of this stub
    return {
      success: true,
      pullRequestUrl: pullRequestResult.pullRequestUrl,
    };
  } catch (error) {
    // TODO: temporary error handler until i figure out how to deal with global errors in yoga which seems maybe impossible
    if (error instanceof GraphQLYogaError) {
      log.warn('handled graphql yoga error, returning error to client', { error });
    } else {
      log.error('UNKNOWN ERROR IN GRAPHQL RESOLVER', { e: error });
    }
    throw error;
  }
};
